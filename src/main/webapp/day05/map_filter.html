<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>map, some, every, filter, reduce</title>
	</head>
	<body>
 
 		<script type="text/javascript">
 			
 			/* map : 배열 내의 모든 요소 각각에 대해서 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환 */
 		
 			const numbers = [1, 4, 9, 16];
 			
 			//const result = numbers.map(callback);
 			
 			//	원래 구문
 			const result = numbers.map(function(num) {
				//	배열의 각 요소마다 곱하기 2
 				return num * 2;
			});
 			console.log(result);
 			
 			//	이때 x 는 numbers 배열 각각의 요소
 			const result2 = numbers.map(x => x*2);
 			console.log(result2);

 			//	또 다른 방법
			//	현실에서는 DB 정보 또는 제공하는 정보가 객체인 경우가 많다.
 			class Student {
				//	생성자
 				constructor(name, kor, eng, math) {
					this.name = name;
					this.kor = kor;
					this.eng = eng;
					this.math = math;
				}
			}
 			
 			const student1 = new Student(`홍길동`, 95, 87, 75);
 			const student2 = new Student(`김길동`, 67, 80, 100);
 			const student3 = new Student(`고길동`, 89, 75, 80);
 			const student4 = new Student(`최길동`, 48, 52, 98);
 			
 			const students = [student1, student2, student3, student4];
 			
 			console.log(`영어점수` , students.map(k => k.eng));
		 		
 			/* some : 배열 안에서 주어진 조건을 하나라도 만족하면 true */
 			console.log(`숫자가 7 이상인 숫자가 있나요? : ` , numbers.some(x => x >= 7));
 			console.log(`수학점수가 100점인 학생이 있나요? : ` , students.some(x => x.math === 100));
 			console.log(`영어점수가 50점 미만인 학생이 있나요? : ` , students.some(x => x.eng < 50));
 			
 			/* every : 배열 안에서 주어진 조건을 모든 요소가 만족하면 true (하나라도 만족하지 않으면 false) */
 			console.log(`숫자가 모두 7 이상인가요? : ` , numbers.every(x => x >= 7));
 			console.log(`수학점수가 모두 70점 이상인가요? : ` , students.every(x => x.math >= 70));
 			
 			/* filter : 배열 안에서 주어진 조건에 만족하는 요소들만 모아 새로운 배열을 반환 */
 			console.log(`숫자 중 홀수만 출력하기 : ` , numbers.filter(x => x%2 === 1));
 			console.log(`영어점수가 80점 이상 인 학생만 출력하기 : ` , students.filter(x => x.eng >= 80));
 			
 			/* 
 				reduce : 배열의 각 요소에 주어진 리듀서 함수를 실행하고, **하나의 결과값을 반환한다. 
 					리듀서 함수 => acc(누적값), cur(현재값), idx(현재인덱스), src(원본배열)
 						**보통 누적합, 중복제거에 사용한다.

	 			형식)	배열.reduce((acc, cur, idx, src) => {
	 					실행내용	
	 				return 리턴값}, 초기값);
 				
 			*/
 			
 			//	1. 누적합
 			const numbers2 = [1, 4, 9, 16];
 			
 			numbers2.reduce((acc, cur, idx, src) => {
 				console.log(`acc : ${acc}, cur : ${cur}, idx : ${idx}, src : ${src}`);
 				return acc;
 			}, 0);

 			console.log(`========================================`);
 			
 			numbers2.reduce((acc, cur, idx, src) => {
 				console.log(`acc : ${acc}, cur : ${cur}, idx : ${idx}, src : ${src}`);
 				return acc;
 			}, 1);
 			
 			console.log(`========================================`);
 			
 			//	누적값은 acc + 현재값
 			numbers2.reduce((acc, cur, idx, src) => {
 				console.log(`acc : ${acc}, cur : ${cur}, idx : ${idx}, src : ${src}`);
 				return acc + cur;
 			}, 0);
 			
 			console.log(`========================================`);

 			//	하나의 결과값이 반환되므로 저장해주자
 			const result3 = numbers2.reduce((acc, cur, idx, src) => {
 				return acc + cur;
 			}, 0);
 			console.log(`결과 : ${result3}`);
 			
 			console.log(`========================================`);
 			
 			//	2. 중복제거
 			const fruits = [`사과`, `딸기`, `배`, `참외`, `딸기`, `수박`];
 			
 			//	비어있는 배열에서 includes 을 이용해서 중복제거
 			console.log(fruits);
 			
 			const result4 = fruits.reduce((acc, cur) => {
 				//	누적값에 현재값이 포함되어 있는지
 				if (acc.includes(cur) === false) {
 					//	포함되어 있지 않으면 누적값 배열에 넣기
					acc.push(cur);
				}
 				return acc;
 			//	누적값이 배열이므로 초기값에 빈배열을 넣어주자
 			}, []);
 			
 			console.log(result4);
 			
 		</script>
	
	</body>
</html>